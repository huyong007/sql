## 事务
- 事务就是保证一组数据库操作,要么全部成功,要么全部失败.
- MySQL支持多引擎的系统,MyISAM 引擎不支持事务,这也是被InnoDB取代的原因之一
- 事务的特性:ACID(Atomicity-原子性、Consistency-一致性、Isolation-隔离性、Durability-持久性)
- 多个事务同时执行可能存在:脏读(dirty read)、不可重复度(non-repeatable read)、幻读(phantom read)的问题
- SQL标准的事务隔离级别包括
  + 读未提交(read uncommitted):一个事务还没提交时,它做的变更就能被别的事务看到
  + 读提交(read committed):一个事务提交之后,它做的变更才会被其他事务看到
  + 可重复读(repeatable read):一个事务执行过程中看到的数据,总是跟这个事务在启动时看到的数据是一致的.当然在可重复读隔离级别下,未提交变更对其他事务也是不可见的.
  + 串行化(serializable):对于同一行记录,‘写’会加‘写锁’,‘读’会加‘读锁’.当出现读写锁冲突的时候,后访问的事务必须等前一个事务执行完成,才能继续执行.

- SQL事务隔离实现的方式---视图:
  + RR‘可重复读‘隔离级别下,视图是在事务启动时候创建的,整个事务存在期间都用整个视图
  + RC‘读提交’隔离级别下,视图在每个SQL语句开始执行的时候创建,并不是事务启动时候创建,
  + RU‘读未提交‘隔离级别下,直接返回记录上的最新值,没有视图概念
  + Serial'串行化'隔离级别下,直接用加锁的方式避免并行访问
  
- 隔离级别设置参数:transaction-isolation,查看其值的方式
  + show variables like 'transaction_isolation'

- 事务隔离的实现方式:回滚日志
  + 在MySQL中,实际上每天记录在更新的时候都会同时记录一条回滚操作,记录上的最新值,通过回滚操作,都可以得到前一个状态的值
  + 不同时刻启动的事务会有不同的read-view,同一条记录在系统中可以存在多个版本,这就是数据库的多版本并发控制(MVCC)
  * 回滚日志删除的时机:
    + 系统判断,当没有事务再需要用到这些日志时候,回滚日志会被删除
  * 避免使用长事务
    + 长事务导致回滚记录:长事务意味着系统里面会存在很老的事务视图,由于这些事务随时可能访问数据库里面的任何数据,所以这个事务提交之前,数据库里面它可能用到的回滚记录都必须保留,这就会导致大量的占用存储空间
    + MySQL5.5和以前版本,回滚日志是跟数据字典一起放在ibdata文件里的,即使长事务最终提交,回滚段被清理,文件也不会变小
    + 长事务还占用锁资源,也可能拖垮整个库

  + MySQL事务启动的方式:
    * 显示启动事务语句,begin或start transaction ,配套的提交语句是commit,回滚语句是rollback
    * set autocommit=0,关掉线程的自动提交,除非主动commit或rollback语句,或断开链接,这样就导致了长事务
  * autocommit=1情况下,用begin显示启动的事务,如果执行commit则提交事务,如果执行commit work and chain,则是提交事务并自动启动下一个事务省区了执行begin的语句开销