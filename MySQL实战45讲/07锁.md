- mysql的行锁是在引擎层由各个引擎自己实现的
- MyISAM引擎不支持行锁,对于这种引擎的表,同一张表任何时刻只要由一个更新在执行,就回影响业务并发度
- InnoDB支持行锁
- 在InnoDB事务中,行锁是在需要的时候才加上的,但并不是不需要了就立刻释放,而是要等到事务结束时才释放,这个就是两阶段锁协议
- 如果你的事务中需要锁多个行,要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放
- 当并发系统中不同线程出现循环资源依赖,涉及的线程都在等待别的线程释放资源时,就回导致这几个线程都进入无限等待的状态,称为死锁.
### 解决死锁的两种策略:
#### 方向:控制访问相同资源的并发事务量
  + 直接进入等待,直到超时,这个超时时间可以通过参数innodb_lock_wait_timeout来设置(时间太短容易造成误伤简单的锁等待)
  + 发起死锁检测,发现死锁后,主动回滚死锁链条后,主动回滚死锁链条中国呢的某一个事务,让其他事务得以继续执行.将参数innodb_deadlock_detect设置为on,表示开启这个逻辑(正常情况使用这个策略)

- 死锁检测存在的问题:每当一个事务被锁的时候,就要看看他所依赖的线程有没有被别人锁住,如此循环,最后判断是否出现了循环等待,也就是死锁
### 解决热点行更新导致的性能问题
- 确保一个业务一定不会出现死锁,可以临时把死锁检测关掉,这可能造成大量的超时,有损业务
- 控制并发度,对mySQL源码进行修改,对于相同行的更新,在进入引擎之前排队,这样在innoDB内部就不会有大量的死锁检测工作了
- 设计上优化,将一行改成逻辑上的多行减少锁冲突,并注意,一部分行记录变成0的时候,代码要有特殊处理
- 

