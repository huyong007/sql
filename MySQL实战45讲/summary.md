## 核心概念
- MySQL 建立一条连接成本包括:网络连接的三次握手,还需要做登录权限判断和获得这个连接的数据读写权限
- 一条查询语句执行过程经历一般是：连接器->分析器->优化器->执行器等功能模块，最后到达存储引擎
  + 连接器：管理连接，权限验证
  + 分析器：吃法分析，语法分析
  + 查询缓存：命中则直接返回结果
  + 优化器：执行计划生成，索引选择
  + 执行器：操作引擎，返回结果
  + 存储引擎：存储数据，提供读写接口
- redo log 重做日志:保证异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**，这个是InnoDB特有的日志
- binlog 归档日志
  + 两个日志的异同点：
    * redo log 是InnoDB引擎特有的；binlog是MySQL的Server层面实现的，所有引擎都可以使用
    * redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始路基，比如，给id=2这一行的c字段加1
    * redo log是循环写的，空间固定会用完；binlog是可以追加写入的，“追加写”是指binlog文件写到一定大小会切换到写一个并不会覆盖以前的日志
- WAL技术--Write-Ahead Logging ，先写日志，再写磁盘
- 数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景
- 当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”
- 内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，成为‘干净页’
- InnoDB使用缓存池（buffer pool）管理内存，缓存池中的内存页有三种状态：
  + 还没有使用的
  + 使用了并且是干净页
  + 使用了并且是脏页
- InnoDB的刷盘速度参考两个因素：
  + 脏页比例
  + redo log写盘速度
- 建议将innodb_file_per_table设置为ON；如此，每个InnoDB表数据存储在一个以.ibd为后缀的文件中，一个表单独存储为一个文件更容易管理，不需要的时候，通过drop table命令，系统直接删除这个文件，如果放在共享表空间中也就是为OFF的时候，表删除了，空间也不会回收
- 全字段排序,MySQL会给每一个线程分配一块内存用于排序，称为sort_buffer,排序过程中只是用内存进行排序还是使用外部排序取决于sort_buffer_size；外部排序一般使用归并排序算法
- rowid排序
- MySQL的设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问
- 覆盖索引指的是：索引上的信息足够满足查询请求，不需要再回到主键上来去数据
- 对于内存表，回表过程只是简单的根据数据行的位置，直接访问内存得到的数据，根本不会导致多访问磁盘
- 删除数据的时候尽量加limit,不仅可以控制删除数据的条数,让操作更安全,还可以减少加锁的范围
- max_connections 控制MySQL实例同时存在的连接数的上线,超过这个值,系统会拒绝接下来的连接请求,并报错提示:Too many connection ,对于拒绝链接的请求来说就是数据库不可用
- 在mysql中引发性能问题的慢查询,大体有以下三种可能:
  + 索引没有设计好-- 紧急创建索引来解决
  + sql语句没写好
  + mysql选错了索引
- 


### 查询语句
- select 
- from 
- order by 
- desc
- group by 
- where
- and
- or
- not
- having 满足where不能和聚合语句group by联合使用
- inner join ... on ... 会形成一个表 查询结束就没了,常用于需要计算的子表数据的情况
- min
- max
- avg
- sum
- count
- as
- limit 
- offset
- like
- 窗口函数 <窗口函数> over (partition by <用于分组的列名> order by <用于排序的列名>) 
- 窗口函数位置可以放置如下两种函数:
  + rank,dese_rank,row_number(函数括号内无需放置聚合的列名)
  + sum,avg,count,max,min(函数括号内需要放置需要聚合的列名)
- 窗口函数绝大部分都是作为select子句来使用
- 窗口函数总结的
- alter table SUser and index index2(email(6)) // 给SUser表加上索引index2并选取邮箱这个字符串字段的前六位作为索引

### 不清晰的概念：
- memory引擎
- 归并排序
- 间隙锁
- 上行锁
- 可重复读隔离级别(repeatable-read):遵循两阶段锁协议,所有枷锁的资源,都是在事物提交或者回滚的时候才释放的
  + 加锁规则:
    * 原则1:加锁的基本单位是next-key lock,next-keylock 是前开后闭区间
    * 原则2:查找过程中访问到的对象才会枷锁
    * 优化1:索引上的等值查询,给唯一索引加锁的时候,next-keylock退化为行锁
    * 优化2:索引上的等值查询,向右遍历时且最后一个值不满足等值条件的时候,next-key lock 退化为间隙锁
    * 一个bug:唯一索引上的范围查询会访问到不满足条件的第一个值为止
- 读提交隔离级别(read-committed)
  + 加锁规则:
    * 优化:语句执行过程中加上的行锁,在语句执行完成后,就要把‘不满足条件的行'上的行锁直接释放了,不需要等到事务的提交,也就是说在读提交隔离级别下,锁的范围更小,锁的时间更短,这也是不少业务都默认使用读提交隔离级别的原因
- next-key lock 实际上是由间隙锁加行锁实现的
- 有间隙的地方就有可能有间隙锁
- 什么是事务内?什么是事务外?
- 什么是慢查询?
- WAL机制主要得益于两个方面:
  + redo log 和binlog都是顺序写,磁盘的顺序写比随机写速度更快
  + 组提交机制,可以大幅降低磁盘的iops消耗
- 执行`show binlog events in 'master.000001'`出现`Error when executing command SHOW BINLOG EVENTS: Could not find target log`